//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { DateTime, Duration } from "luxon";

export class Client {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    exams_AllExams(professorId: string | undefined): Promise<Exam[]> {
        let url_ = this.baseUrl + "/api/Exams/AllExams?";
        if (professorId === null)
            throw new Error("The parameter 'professorId' cannot be null.");
        else if (professorId !== undefined)
            url_ += "professorId=" + encodeURIComponent("" + professorId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExams_AllExams(_response);
        });
    }

    protected processExams_AllExams(response: Response): Promise<Exam[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Exam.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Exam[]>(null as any);
    }

    exams_QuestionsFromExam(examId: string | undefined): Promise<ExamDTO> {
        let url_ = this.baseUrl + "/api/Exams/QuestionsFromExam?";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExams_QuestionsFromExam(_response);
        });
    }

    protected processExams_QuestionsFromExam(response: Response): Promise<ExamDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ExamDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<ExamDTO>(null as any);
    }

    exams_CreateExam(body: CreateExamRequest): Promise<Exam> {
        let url_ = this.baseUrl + "/api/Exams/CreateExam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExams_CreateExam(_response);
        });
    }

    protected processExams_CreateExam(response: Response): Promise<Exam> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Exam.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Exam>(null as any);
    }

    exams_AddQuestions(examId: string | undefined, questions: string[]): Promise<void> {
        let url_ = this.baseUrl + "/api/Exams?";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(questions);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExams_AddQuestions(_response);
        });
    }

    protected processExams_AddQuestions(response: Response): Promise<void> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            return;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<void>(null as any);
    }

    exams_UpdateExam(body: UpdateExamRequest): Promise<Exam> {
        let url_ = this.baseUrl + "/api/Exams/UpdateExam";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processExams_UpdateExam(_response);
        });
    }

    protected processExams_UpdateExam(response: Response): Promise<Exam> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Exam.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Exam>(null as any);
    }

    promptEngineering_BatchQuestionGeneration(requestData: QuestionBatchRequest): Promise<string[]> {
        let url_ = this.baseUrl + "/api/PromptEngineering/BatchQuestionGeneration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPromptEngineering_BatchQuestionGeneration(_response);
        });
    }

    protected processPromptEngineering_BatchQuestionGeneration(response: Response): Promise<string[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string[]>(null as any);
    }

    promptEngineering_SingleQuestionGeneration(requestData: QuestionSingleRequest): Promise<string> {
        let url_ = this.baseUrl + "/api/PromptEngineering/SingleQuestionGeneration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPromptEngineering_SingleQuestionGeneration(_response);
        });
    }

    protected processPromptEngineering_SingleQuestionGeneration(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    promptEngineering_BatchAnswerGeneration(requestData: AnswerBatchRequest): Promise<{ [key: string]: string; }> {
        let url_ = this.baseUrl + "/api/PromptEngineering/BatchAnswerGeneration";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processPromptEngineering_BatchAnswerGeneration(_response);
        });
    }

    protected processPromptEngineering_BatchAnswerGeneration(response: Response): Promise<{ [key: string]: string; }> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<{ [key: string]: string; }>(null as any);
    }

    session_GetSessionsByExam(examId: string | undefined): Promise<Session[]> {
        let url_ = this.baseUrl + "/api/Session/GetSessionsByExam?";
        if (examId === null)
            throw new Error("The parameter 'examId' cannot be null.");
        else if (examId !== undefined)
            url_ += "examId=" + encodeURIComponent("" + examId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSession_GetSessionsByExam(_response);
        });
    }

    protected processSession_GetSessionsByExam(response: Response): Promise<Session[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Session.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Session[]>(null as any);
    }

    session_GetAnswersBySession(sessionId: string | undefined): Promise<Answer[]> {
        let url_ = this.baseUrl + "/api/Session/GetAnswersBySession?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSession_GetAnswersBySession(_response);
        });
    }

    protected processSession_GetAnswersBySession(response: Response): Promise<Answer[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Answer.fromJS(item));
            }
            else {
                result200 = <any>null;
            }
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Answer[]>(null as any);
    }

    session_UpdateSessionFeedback(requestData: UpdateSessionRequest): Promise<Session> {
        let url_ = this.baseUrl + "/api/Session/UpdateSessionFeedback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(requestData);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSession_UpdateSessionFeedback(_response);
        });
    }

    protected processSession_UpdateSessionFeedback(response: Response): Promise<Session> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Session.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<Session>(null as any);
    }

    session_GetSessionStats(sessionId: string | undefined): Promise<SessionStatsDTO> {
        let url_ = this.baseUrl + "/api/Session/GetSessionStats?";
        if (sessionId === null)
            throw new Error("The parameter 'sessionId' cannot be null.");
        else if (sessionId !== undefined)
            url_ += "sessionId=" + encodeURIComponent("" + sessionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processSession_GetSessionStats(_response);
        });
    }

    protected processSession_GetSessionStats(response: Response): Promise<SessionStatsDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SessionStatsDTO.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<SessionStatsDTO>(null as any);
    }

    users_CreateUser(body: CreateUserRequest): Promise<User> {
        let url_ = this.baseUrl + "/api/Users/CreateUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers_CreateUser(_response);
        });
    }

    protected processUsers_CreateUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    users_GetUser(id: string | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/Users/GetUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers_GetUser(_response);
        });
    }

    protected processUsers_GetUser(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    users_GetUserByName(name: string | undefined): Promise<User> {
        let url_ = this.baseUrl + "/api/Users/GetUserByName?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processUsers_GetUserByName(_response);
        });
    }

    protected processUsers_GetUserByName(response: Response): Promise<User> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<User>(null as any);
    }

    openAI_TestTextCompletion(query: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/OpenAI/TestTextCompletion?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenAI_TestTextCompletion(_response);
        });
    }

    protected processOpenAI_TestTextCompletion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    openAI_TestChatCompletion(query: string | undefined, model: string | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/OpenAI/TestChatCompletion?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        if (model === null)
            throw new Error("The parameter 'model' cannot be null.");
        else if (model !== undefined)
            url_ += "model=" + encodeURIComponent("" + model) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.http.fetch(url_, options_).then((_response: Response) => {
            return this.processOpenAI_TestChatCompletion(_response);
        });
    }

    protected processOpenAI_TestChatCompletion(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }
}

export class Exam implements IExam {
    id?: string;
    title!: string;
    owner?: User;
    ownerId?: string;
    topics?: string[];

    constructor(data?: IExam) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.owner = _data["owner"] ? User.fromJS(_data["owner"]) : <any>undefined;
            this.ownerId = _data["ownerId"];
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
        }
    }

    static fromJS(data: any): Exam {
        data = typeof data === 'object' ? data : {};
        let result = new Exam();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["owner"] = this.owner ? this.owner.toJSON() : <any>undefined;
        data["ownerId"] = this.ownerId;
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        return data;
    }
}

export interface IExam {
    id?: string;
    title: string;
    owner?: User;
    ownerId?: string;
    topics?: string[];
}

export class User implements IUser {
    id?: string;
    name!: string;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data;
    }
}

export interface IUser {
    id?: string;
    name: string;
}

export class ExamDTO implements IExamDTO {
    exam?: Exam;
    questions?: Question[];

    constructor(data?: IExamDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.exam = _data["exam"] ? Exam.fromJS(_data["exam"]) : <any>undefined;
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(Question.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ExamDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ExamDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["exam"] = this.exam ? this.exam.toJSON() : <any>undefined;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IExamDTO {
    exam?: Exam;
    questions?: Question[];
}

export class Question implements IQuestion {
    id?: string;
    text?: string;
    exam?: Exam;
    examId?: string;

    constructor(data?: IQuestion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.exam = _data["exam"] ? Exam.fromJS(_data["exam"]) : <any>undefined;
            this.examId = _data["examId"];
        }
    }

    static fromJS(data: any): Question {
        data = typeof data === 'object' ? data : {};
        let result = new Question();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["exam"] = this.exam ? this.exam.toJSON() : <any>undefined;
        data["examId"] = this.examId;
        return data;
    }
}

export interface IQuestion {
    id?: string;
    text?: string;
    exam?: Exam;
    examId?: string;
}

export class CreateExamRequest implements ICreateExamRequest {
    title?: string;
    questions?: string[];
    topics?: string[];
    professorId?: string;

    constructor(data?: ICreateExamRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(item);
            }
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
            this.professorId = _data["professorId"];
        }
    }

    static fromJS(data: any): CreateExamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateExamRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item);
        }
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        data["professorId"] = this.professorId;
        return data;
    }
}

export interface ICreateExamRequest {
    title?: string;
    questions?: string[];
    topics?: string[];
    professorId?: string;
}

export class UpdateExamRequest extends CreateExamRequest implements IUpdateExamRequest {
    examId?: string;

    constructor(data?: IUpdateExamRequest) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.examId = _data["examId"];
        }
    }

    static override fromJS(data: any): UpdateExamRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateExamRequest();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["examId"] = this.examId;
        super.toJSON(data);
        return data;
    }
}

export interface IUpdateExamRequest extends ICreateExamRequest {
    examId?: string;
}

export class QuestionBatchRequest implements IQuestionBatchRequest {
    topics?: string[];
    qNumber?: number;
    model?: string;

    constructor(data?: IQuestionBatchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
            this.qNumber = _data["qNumber"];
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): QuestionBatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionBatchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        data["qNumber"] = this.qNumber;
        data["model"] = this.model;
        return data;
    }
}

export interface IQuestionBatchRequest {
    topics?: string[];
    qNumber?: number;
    model?: string;
}

export class QuestionSingleRequest implements IQuestionSingleRequest {
    topics?: string[];
    question?: string;
    model?: string;

    constructor(data?: IQuestionSingleRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["topics"])) {
                this.topics = [] as any;
                for (let item of _data["topics"])
                    this.topics!.push(item);
            }
            this.question = _data["question"];
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): QuestionSingleRequest {
        data = typeof data === 'object' ? data : {};
        let result = new QuestionSingleRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.topics)) {
            data["topics"] = [];
            for (let item of this.topics)
                data["topics"].push(item);
        }
        data["question"] = this.question;
        data["model"] = this.model;
        return data;
    }
}

export interface IQuestionSingleRequest {
    topics?: string[];
    question?: string;
    model?: string;
}

export class AnswerBatchRequest implements IAnswerBatchRequest {
    answers?: { [key: string]: string; };
    saveAnswer?: boolean | undefined;
    studentId?: string | undefined;
    model?: string | undefined;

    constructor(data?: IAnswerBatchRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["answers"]) {
                this.answers = {} as any;
                for (let key in _data["answers"]) {
                    if (_data["answers"].hasOwnProperty(key))
                        (<any>this.answers)![key] = _data["answers"][key];
                }
            }
            this.saveAnswer = _data["saveAnswer"];
            this.studentId = _data["studentId"];
            this.model = _data["model"];
        }
    }

    static fromJS(data: any): AnswerBatchRequest {
        data = typeof data === 'object' ? data : {};
        let result = new AnswerBatchRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.answers) {
            data["answers"] = {};
            for (let key in this.answers) {
                if (this.answers.hasOwnProperty(key))
                    (<any>data["answers"])[key] = (<any>this.answers)[key];
            }
        }
        data["saveAnswer"] = this.saveAnswer;
        data["studentId"] = this.studentId;
        data["model"] = this.model;
        return data;
    }
}

export interface IAnswerBatchRequest {
    answers?: { [key: string]: string; };
    saveAnswer?: boolean | undefined;
    studentId?: string | undefined;
    model?: string | undefined;
}

export class Session implements ISession {
    id?: string;
    student?: User;
    studentId?: string;
    exam?: Exam;
    examId?: string;

    constructor(data?: ISession) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.student = _data["student"] ? User.fromJS(_data["student"]) : <any>undefined;
            this.studentId = _data["studentId"];
            this.exam = _data["exam"] ? Exam.fromJS(_data["exam"]) : <any>undefined;
            this.examId = _data["examId"];
        }
    }

    static fromJS(data: any): Session {
        data = typeof data === 'object' ? data : {};
        let result = new Session();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["student"] = this.student ? this.student.toJSON() : <any>undefined;
        data["studentId"] = this.studentId;
        data["exam"] = this.exam ? this.exam.toJSON() : <any>undefined;
        data["examId"] = this.examId;
        return data;
    }
}

export interface ISession {
    id?: string;
    student?: User;
    studentId?: string;
    exam?: Exam;
    examId?: string;
}

export class Answer implements IAnswer {
    id?: string;
    session?: Session;
    sessionId?: string;
    text?: string;
    feedback?: string;
    question?: Question;
    questionId?: string;

    constructor(data?: IAnswer) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.session = _data["session"] ? Session.fromJS(_data["session"]) : <any>undefined;
            this.sessionId = _data["sessionId"];
            this.text = _data["text"];
            this.feedback = _data["feedback"];
            this.question = _data["question"] ? Question.fromJS(_data["question"]) : <any>undefined;
            this.questionId = _data["questionId"];
        }
    }

    static fromJS(data: any): Answer {
        data = typeof data === 'object' ? data : {};
        let result = new Answer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["sessionId"] = this.sessionId;
        data["text"] = this.text;
        data["feedback"] = this.feedback;
        data["question"] = this.question ? this.question.toJSON() : <any>undefined;
        data["questionId"] = this.questionId;
        return data;
    }
}

export interface IAnswer {
    id?: string;
    session?: Session;
    sessionId?: string;
    text?: string;
    feedback?: string;
    question?: Question;
    questionId?: string;
}

export class UpdateSessionRequest implements IUpdateSessionRequest {
    sessionId?: string | undefined;
    answerFeedback?: { [key: string]: string; };

    constructor(data?: IUpdateSessionRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sessionId = _data["sessionId"];
            if (_data["answerFeedback"]) {
                this.answerFeedback = {} as any;
                for (let key in _data["answerFeedback"]) {
                    if (_data["answerFeedback"].hasOwnProperty(key))
                        (<any>this.answerFeedback)![key] = _data["answerFeedback"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpdateSessionRequest {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateSessionRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sessionId"] = this.sessionId;
        if (this.answerFeedback) {
            data["answerFeedback"] = {};
            for (let key in this.answerFeedback) {
                if (this.answerFeedback.hasOwnProperty(key))
                    (<any>data["answerFeedback"])[key] = (<any>this.answerFeedback)[key];
            }
        }
        return data;
    }
}

export interface IUpdateSessionRequest {
    sessionId?: string | undefined;
    answerFeedback?: { [key: string]: string; };
}

export class SessionStatsDTO implements ISessionStatsDTO {
    status?: string;
    grade?: number;

    constructor(data?: ISessionStatsDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.grade = _data["grade"];
        }
    }

    static fromJS(data: any): SessionStatsDTO {
        data = typeof data === 'object' ? data : {};
        let result = new SessionStatsDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["grade"] = this.grade;
        return data;
    }
}

export interface ISessionStatsDTO {
    status?: string;
    grade?: number;
}

export class CreateUserRequest implements ICreateUserRequest {
    userName?: string;

    constructor(data?: ICreateUserRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
        }
    }

    static fromJS(data: any): CreateUserRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        return data;
    }
}

export interface ICreateUserRequest {
    userName?: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}